---
status: queued
---

# Implement dark-factory MVP main loop

## Goal

Build the dark-factory CLI: a Go program that watches `./prompts/` for prompt files with `status: queued` in YAML frontmatter, executes them via a Docker container (claude-yolo), and on success commits + versions + pushes.

Run with no arguments from project root: `dark-factory`

## Architecture

Follow the patterns in CLAUDE.md. Use packages:

- `pkg/prompt/` — parse and update YAML frontmatter in markdown files, list prompt files
- `pkg/executor/` — run Docker container, check exit code
- `pkg/git/` — commit, tag, push
- `pkg/factory/` — main loop orchestrating the above

## Main Loop (pkg/factory/)

```
loop:
  scan prompts/*.md for files with frontmatter status: queued
  if none found: exit 0
  pick first (alphabetical order)
  set status: executing
  run executor
  if exit 0:
    git add -A
    read CHANGELOG.md, add prompt title to ## Unreleased section
    bump patch version: rename ## Unreleased → ## vX.Y.Z
    git commit -m "release vX.Y.Z"
    git tag vX.Y.Z
    git push && git push origin vX.Y.Z
    set status: completed
    move file to prompts/completed/
    loop again
  if exit non-0:
    set status: failed
    exit 1
```

## Prompt Parsing (pkg/prompt/)

Prompt files are markdown with YAML frontmatter:

```markdown
---
status: queued
---

# Title here

Content here...
```

- `no frontmatter` or `no status field` = drafting (ignore)
- `status: queued` = ready to execute
- `status: executing` = in progress
- `status: completed` = done
- `status: failed` = error

Implement:
- `ListQueued(dir string) ([]Prompt, error)` — find all .md files with status: queued, sorted alphabetically
- `SetStatus(path string, status string) error` — update frontmatter status field
- `Title(path string) (string, error)` — extract first `# heading` from content (below frontmatter)
- `Content(path string) (string, error)` — return full file content (for passing to Docker)
- `MoveToCompleted(path string) error` — move file to `completed/` subdirectory

Use `go.yaml.in/yaml/v3` for YAML parsing (already in go.mod as indirect dep).

## Docker Executor (pkg/executor/)

Run the claude-yolo Docker container in **attached mode** (blocking, no `-dit`):

```go
cmd := exec.Command("docker", "run", "--rm",
    "--cap-add=NET_ADMIN", "--cap-add=NET_RAW",
    "-e", "YOLO_PROMPT="+promptContent,
    "-v", projectRoot+":/workspace",
    "-v", home+"/.claude-yolo:/home/node/.claude",
    "-v", home+"/go/pkg:/home/node/go/pkg",
    "docker.io/bborbe/claude-yolo:latest")
cmd.Stdout = os.Stdout
cmd.Stderr = os.Stderr
err := cmd.Run()
```

- Use `os/exec` with `cmd.Run()` — blocks until container exits
- Pipe stdout/stderr directly to `os.Stdout`/`os.Stderr` for live output
- Exit code comes from `cmd.Run()` error (use `exec.ExitError` to extract code)
- No `-dit`, no `docker wait`, no `docker logs` — attached mode is simplest
- Project root = current working directory (`os.Getwd()`)
- Home = `os.UserHomeDir()`

## Git Operations (pkg/git/)

Implement:
- `CommitAndRelease(changelogEntry string) error` — does the full sequence:
  1. `git add -A`
  2. Read CHANGELOG.md
  3. If `## Unreleased` section exists with entries, add changelogEntry, then rename to `## vX.Y.Z` (patch bump from latest tag)
  4. If no `## Unreleased`, create `## vX.Y.Z` section with changelogEntry
  5. Get latest tag via `git describe --tags --abbrev=0`, bump patch
  6. If no tags exist, start with `v0.1.0`
  7. `git add -A` again (for CHANGELOG changes)
  8. `git commit -m "release vX.Y.Z"`
  9. `git tag vX.Y.Z`
  10. `git push`
  11. `git push origin vX.Y.Z`

Use `os/exec` for git commands.

## Entry Point (main.go)

```go
func main() {
    if err := run(); err != nil {
        fmt.Fprintf(os.Stderr, "error: %v\n", err)
        os.Exit(1)
    }
}

func run() error {
    f := factory.New()
    return f.Run(context.Background())
}
```

## Testing

- Write Ginkgo v2 tests for `pkg/prompt/` (parsing, status updates, listing)
- Write Ginkgo v2 tests for `pkg/git/` (version bumping logic — parse semver, increment patch)
- Factory and executor are integration-heavy — compile test is sufficient for MVP

## Constraints

- No external dependencies beyond what's in go.mod (yaml is already indirect)
- No config files — everything hardcoded for MVP
- No watching/polling — single scan + execute loop, exit when no more queued prompts
- Keep it simple — no interfaces where a concrete struct suffices for MVP
- All git/docker commands via os/exec
- Run `make precommit` before finishing to ensure everything passes
